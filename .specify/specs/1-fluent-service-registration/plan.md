# Implementation Plan: fluent-service-registration

**Branch**: `1-fluent-service-registration` | **Date**: 2025-11-16 | **Spec**: ./spec.md  
**Input**: Feature specification from `/specs/1-fluent-service-registration/spec.md`

## Summary

Provide a small, opt-in fluent API on top of Microsoft.Extensions.DependencyInjection to make common registration patterns (bind and decorator stacks accepting Func\<T\> next) more ergonomic. The implementation must translate each fluent call to equivalent IServiceCollection ServiceDescriptor registrations without introducing behavior beyond the DI runtime and must remain minimal and auditable.

Reference implementation (prototype) is the provided C# program that:
- Adds a WithBindings extension accepting an IFluentBinder
- Implements Bind\<TService\>().To\<TImpl\>() by registering the implementation type, an InnerFactory\<TService\> returning Func\<TService\> seed, and a public TService factory that invokes the inner factory.
- Implements Decorate\<TService\>().With\<TDecorator\>() by updating InnerFactory\<TService\> to return a new Func\<TService\> that constructs the decorator with the previous Func\<TService\> as next using ActivatorUtilities.CreateInstance, and re-registering the public factory to invoke the top-level factory.

This plan documents compatibility, tests, and constitution checks.

## Technical Context

**Language/Version**: C# .NET (validate target frameworks in Phase 1)  
**Target Platform**: netstandard2.0 and net10 (supported target frameworks will be finalized in Phase 1)  
**Primary Dependencies**: Microsoft.Extensions.DependencyInjection (already in use); avoid adding other runtime packages.  
**Storage**: N/A  
**Testing**: xUnit (unit + integration), Host/GenericHost integration tests.  
**Project Type**: Single project library (package) delivering the fluent API extension.  
**Performance Goals**: No measurable regression compared to equivalent manual factory registration; keep allocations minimal.  
**Constraints**: Must not change IServiceCollection or ServiceDescriptor semantics; must produce deterministic ServiceDescriptors for observability.  
**Scale/Scope**: Library-level feature; small code surface.

## Constitution Check

This plan must pass the constitution gates before Phase 0 research completes. Below are the checks and justifications.

- Code Quality: Unit tests and integration tests are required (see Tests section). Linting/formatting (e.g., dotnet format, Roslyn analyzers) will be configured in CI. (Constitution: Tests MUST cover translations; CI gates required.)
- Modularity: Public API limited to WithBindings, IFluentBinder, IBindSyntax\<T\>, IDecorateSyntax\<T\>. Implementation types (InnerFactory\<T\>, FluentBinder, BindSyntax, DecorateSyntax) marked internal/private. The plan documents compatibility notes: since the API is new and opt-in, changes require MINOR changes in constitution; breaking changes require MAJOR per governance.
- Simple UX: Default behavior maps to standard lifetimes; errors (e.g., missing seed binding when decorating) will be surfaced as clear exceptions at configure time or at runtime with documented diagnostics in plan.md.
- Minimal Dependencies: No new runtime dependencies beyond Microsoft.Extensions.* are required. Any additional dependency will require a documented justification in plan.md and approval per constitution.

If any check cannot be satisfied at planning time, mitigation and acceptance criteria will be added in Phase 1; at present all checks are satisfiable with the provided prototype.

## Project Structure

```text
.specify/specs/1-fluent-service-registration/
├── plan.md
├── research.md          # to be produced in Phase 0
├── data-model.md        # probably N/A; will include mapping of fluent calls -\> ServiceDescriptor
├── quickstart.md        # Phase 1: quick usage examples
├── contracts/           # sample API signatures and public surface
└── tasks.md             # produced next (this file will be generated by /speckit.tasks)

src/
├── FluentDependencyInjection/
│   ├── ServiceCollectionExtensions.cs
│   ├── Binder/
│   │   ├── IFluentBinder.cs
│   │   ├── IBindSyntax.cs
│   │   ├── IDecorateSyntax.cs
│   │   ├── FluentBinder.cs
│   │   ├── BindSyntax.cs
│   │   └── DecorateSyntax.cs
│   └── Internal/
│       └── InnerFactory{T}.cs
tests/
├── unit/
│   ├── BindingsTranslationTests.cs
│   ├── DecoratorStackingTests.cs
│   └── ObservabilityTests.cs
├── integration/
│   ├── HostResolutionTests.cs
│   └── LifetimeBehaviorTests.cs
└── contract/
    └── PublicApiContractTests.cs
```

**Structure Decision**: Single library project named FluentDependencyInjection under src/ with tests/ unit and integration folders. Public API surface is in FluentDependencyInjection root namespace and marked clearly in README.

## Complexity Tracking

No constitution violations identified at plan time. If open generics or named registrations are later requested, justification and complexity matrix will be documented.

## Tests

- Unit tests MUST validate that fluent calls produce ServiceDescriptor entries equivalent to manual registrations (e.g., count of ServiceDescriptors, ServiceType, ImplementationFactory, lifetime).  
- Integration tests MUST validate resolution pipeline behavior in a GenericHost scenario (IServiceProvider built via HostBuilder) and ensure lifetime semantics match expectations.  
- Observability tests: enumerate service descriptors and verify that there is a clear mapping from fluent call to final ServiceDescriptor(s).

## Observability & Diagnostics  
- Implementation will include a small diagnostics helper to enumerate fluent-created registrations and present mapping: e.g., return the ServiceDescriptor list or a simple ReadOnlyDictionary mapping a fluent operation identifier to the created ServiceDescriptors. This helper will be internal-by-default and available via an opt-in diagnostics API to keep public surface minimal.  
- Logging: When decorating, emit a Debug/Trace-level log describing wrapping (e.g., "Decorate\<IService\>: wrapped with DecoratorB -\> new factory registered"). This should be minimal and optional.

## Phase plan & checkpoints
Phase 0: Research & API freeze (deliver research.md)
Phase 1: Implement core Bind/Decorate, unit tests for basic flows, quickstart example (deliver data-model.md, quickstart.md). Gate: Must pass constitution checks.
Phase 2: Integration tests, diagnostics hooks, CI configuration.
Phase 3: Polish, docs, examples, performance review, and maintainers review.

## CI & Review
- Linting and static analysis (Roslyn analyzers) configured.  
- Two maintainer approvals required for merging API changes as per constitution.  
- Tests must run and pass in CI (unit + integration).  
- Code size/complexity metrics tracked; large complexity requires justification.  
- Dependencies  
- Microsoft.Extensions.DependencyInjection (required)  
- No additional runtime dependencies. Any change requires plan.md justification and minimal-deps vetting.

## Dependencies
- Microsoft.Extensions.DependencyInjection (required)
- No additional runtime dependencies. Any change requires plan.md justification and minimal-deps vetting.